# OpenADP Authentication Code System Design

**Replacing OAuth 2.0 + DPoP Authentication with Simplified User-Generated Codes**

---

## 1. Executive Summary

This document proposes replacing OpenADP's current OAuth 2.0 + DPoP + Noise-NK authentication system with a simplified **Authentication Code** approach. The authentication code serves solely to **authenticate users and prevent DoS attacks** on the guess limit system - it does not change OpenADP's core cryptographic protocols.

### Current Problem

OpenADP's authentication system creates operational complexity and performance bottlenecks:

- **Single Point of Failure**: Global Keycloak server at `https://auth.openadp.org`
- **Complex Architecture**: OAuth 2.0 + PKCE + DPoP + Noise-NK + JWT validation
- **Performance Issues**: 5+ network round trips, 5-10 second authentication times
- **Browser Dependencies**: Device code flows require browser interaction
- **Operational Burden**: Maintaining global authentication infrastructure

### Proposed Solution

Replace centralized authentication with **user-generated authentication codes**:

- **Client generates** 128-bit authentication code during backup creation
- **Server-specific codes** derived via `SHA256(auth_code || server_url)`
- **Same cryptographic security**: Pin + Shamir secret sharing unchanged
- **Same key derivation**: `enc_key = HKDF(S.x || S.y)` where `S = s * U`
- **Same blinding protocol**: Servers never see user pins

### Key Benefits

- **Eliminates single point of failure** (no central auth server)
- **Reduces complexity by 90%** (removes OAuth/DPoP/JWT stack)
- **Improves performance 50-100x** (5-10s → 100ms authentication)
- **Maintains all security properties** of current system
- **Simplifies operations** dramatically

---

## 2. Problem Statement

### Current System Flaws
1. **Single Point of Failure**: Global Keycloak server at `https://auth.openadp.org`
2. **Architectural Complexity**: OAuth + DPoP + Noise-NK + JWT validation
3. **Browser Dependencies**: Device code flows require user interaction
4. **Performance Overhead**: 5+ network round trips for authentication
5. **Operational Burden**: Maintaining global authentication infrastructure

### Design Goals
1. **Eliminate SPOF**: No central authentication dependency
2. **Simplify Architecture**: Reduce complexity by 90%
3. **Maintain Security**: Preserve authentication requirements
4. **Improve UX**: Faster, simpler authentication flow
5. **Enable Offline**: Work without internet connectivity to auth servers

---

## 3. Authentication Code Model

### Core Concept
Users generate a **128-bit authentication code** when creating backups with OpenADP. This code serves solely to **authenticate the user** to OpenADP servers, preventing unauthorized DoS attacks on the guess limit system. The authentication code does **not** change OpenADP's cryptographic security model.

### Mathematical Foundation
```
Authentication Code: 128-bit random value generated by client
Server Auth Code = SHA256(auth_code || server_url)

OpenADP Cryptographic Protocol (UNCHANGED):
U = H(UUID, DID, BID, pin)  // User identity point
S = s * U                   // Secret point (s = Shamir secret)
enc_key = HKDF(S.x || S.y)  // Encryption key derivation
```

### Trust Model
- **Client**: Generates auth code, performs OpenADP registration/recovery protocols
- **OpenADP Servers**: Authenticate users with auth codes, store Shamir shares as before
- **User Pin**: Still protected by blinding protocol, never seen by servers
- **Distributed Trust**: Unchanged - still requires T-of-N servers for recovery
- **No Central Authority**: Each server operates autonomously

---

## 4. System Architecture

### 4.1 High-Level Flow

**Registration (Backup Creation)**:
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│      User       │    │   OpenADP Client │    │  OpenADP Server │
│                 │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         │ 1. Backup Request     │                       │
         │ + Pin/Password        │                       │
         │ ──────────────────────►                       │
         │                       │                       │
         │                       │ 2. Generate Auth Code │
         │                       │    (128-bit, internal)│
         │                       │                       │
         │                       │ 3. OpenADP Protocol:  │
         │                       │    • Compute U=H(...)  │
         │                       │    • Generate secret s │
         │                       │    • Create shares     │
         │                       │                       │
         │                       │ 4. Derive server hash │
         │                       │    SHA256(code||URL)  │
         │                       │ ──────────────────────►
         │                       │                       │
         │                       │ 5. Register shares    │
         │                       │    (auth: server hash)│
         │                       │ ──────────────────────►
         │                       │                       │
         │                       │ 6. Derive enc_key     │
         │                       │    Encrypt backup     │
         │                       │                       │
         │                       │ 7. Success            │
         │                       │ ◄──────────────────────
         │                       │                       │
         │ 8. Return Auth Code   │                       │
         │    (for user storage) │                       │
         │ ◄─────────────────────                        │
```

**Recovery (Backup Restoration)**:
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│      User       │    │   OpenADP Client │    │  OpenADP Server │
│                 │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         │ 1. Recovery Request   │                       │
         │ + Pin + Auth Code     │                       │
         │ ──────────────────────►                       │
         │                       │                       │
         │                       │ 2. OpenADP Protocol:  │
         │                       │    • Compute U=H(...)  │
         │                       │    • Generate blinding │
         │                       │    • B = r * U        │
         │                       │                       │
         │                       │ 3. Derive server hash │
         │                       │    SHA256(code||URL)  │
         │                       │ ──────────────────────►
         │                       │                       │
         │                       │ 4. Request shares     │
         │                       │    (auth: server hash)│
         │                       │    Send B to servers  │
         │                       │ ──────────────────────►
         │                       │                       │
         │                       │ 5. Receive s[i] * B   │
         │                       │    Recover S = s * U  │
         │                       │    Derive enc_key     │
         │                       │ ◄──────────────────────
```

### 4.2 Backup Selection Workflow

When users recover backups on a new device, they need to select which backup to restore:

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│      User       │    │   OpenADP Client │    │  OpenADP Server │
│                 │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         │ 1. "Restore backup"   │                       │
         │ + Auth Code + UUID    │                       │
         │ ──────────────────────►                       │
         │                       │                       │
         │                       │ 2. List backups      │
         │                       │    (auth: server hash)│
         │                       │ ──────────────────────►
         │                       │                       │
         │                       │ 3. Return backup list │
         │                       │    [{did, bid, ...}] │
         │                       │ ◄──────────────────────
         │                       │                       │
         │ 4. Show backup list   │                       │
         │    "Android Phone"    │                       │
         │    "Android Tablet"   │                       │
         │ ◄─────────────────────                        │
         │                       │                       │
         │ 5. Select backup      │                       │
         │ ──────────────────────►                       │
         │                       │                       │
         │                       │ 6. Proceed with       │
         │                       │    recovery protocol  │
         │                       │    (as shown above)   │
```

**Example Use Cases**:
- **Android User**: Has backups from phone + tablet, selects which device to restore
- **Apple User**: Typically one backup per device type, but can support multiple
- **Multi-Device**: User can see all their registered devices and choose

### 4.3 Authentication Code Format

```
Base Authentication Code: 32 hex characters (128 bits)
Example: "a1b2c3d4e5f6789012345678901234567890abcd"

Server Authentication Code: SHA256 hash (64 hex characters)  
Example: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
```

### 4.4 Server-Side Data Storage

OpenADP servers store the same data as before, but authenticate requests using authentication codes instead of OAuth tokens:

```sql
-- Updated database schema
CREATE TABLE backups (
    uuid TEXT NOT NULL,          -- User account identifier (e.g., from email)
    did TEXT NOT NULL,           -- Device ID  
    bid TEXT NOT NULL,           -- Backup ID
    auth_code TEXT NOT NULL,     -- Server-specific auth code (SHA256 hash)
    version INTEGER NOT NULL,    -- Protocol version
    x INTEGER NOT NULL,          -- Shamir share X coordinate
    y TEXT NOT NULL,             -- Shamir share Y coordinate (s[i])
    num_guesses INTEGER NOT NULL DEFAULT 0,
    max_guesses INTEGER NOT NULL DEFAULT 10,
    expiration INTEGER NOT NULL DEFAULT 0,
    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    PRIMARY KEY (uuid, did, bid),
    UNIQUE (auth_code)           -- Each auth code is unique
);
```

**Key Changes**:
- `uuid` remains the user account identifier (e.g., derived from email)
- `auth_code` field stores the server-specific authentication code
- Users can query all their backups by UUID
- Authentication happens via the auth_code field
- Same Shamir shares `(x, s[i])` stored as before

### 4.5 Server-Side Processing

**Registration Process**:
1. Validate server authentication code format (64 hex characters from SHA256)
2. Check authentication code uniqueness (prevent duplicates)
3. Store Shamir share with user UUID, device ID, backup ID, and auth code
4. Initialize guess counter and expiration settings

**Recovery Process**:
1. Validate server authentication code format
2. Look up backup record by authentication code
3. Verify backup matches requested UUID/DID/BID
4. Check guess limits (reject if exceeded)
5. Perform blinded share computation: return s[i] * B
6. Update guess counter for rate limiting

**Backup Listing**:
1. Authenticate user with valid authentication code
2. Return all backups associated with the user's UUID
3. Enable backup selection for multi-device scenarios

---

## 5. Security Analysis

### 5.1 Security Properties Maintained

| Property | Current System | Authentication Code System |
|----------|----------------|----------------------------|
| **User Authentication** | ✅ OAuth + DPoP | ✅ Authentication codes |
| **Pin Privacy** | ✅ Blinding protocol | ✅ Blinding protocol (unchanged) |
| **Distributed Trust** | ✅ T-of-N Shamir sharing | ✅ T-of-N Shamir sharing (unchanged) |
| **Guess Limiting** | ✅ Per-user quotas | ✅ Per-auth-code quotas |
| **Replay Protection** | ✅ Session binding | ✅ Server-specific codes |
| **Key Derivation** | ✅ `HKDF(S.x \|\| S.y)` | ✅ `HKDF(S.x \|\| S.y)` (unchanged) |

### 5.2 Security Parameter Analysis

**128-bit Authentication Codes**: We use 128-bit authentication codes, providing a 128-bit security parameter for authentication. This is sufficient because:

- **Attack Model**: Attackers can only perform brute-force guessing attacks (O(2^128) operations)
- **No Algorithmic Attacks**: Unlike discrete log problems, authentication code guessing has no mathematical shortcuts
- **Rate Limiting**: With DDoS defenses, success probability is negligible
- **Quantum Considerations**: 128 bits becomes 64 bits against quantum attacks, but this only affects authentication, not the core cryptographic security
- **Performance**: 128-bit codes are efficient while maintaining adequate security

**Core Cryptographic Security Unchanged**:
- **Pin Security**: Still protected by Ed25519 discrete log hardness via blinding
- **Secret Sharing**: Still uses information-theoretic Shamir secret sharing
- **Key Derivation**: Still uses `enc_key = HKDF(S.x || S.y)` where `S = s * U`
- **Guess Limiting**: Still limited to 10 attempts per backup across all servers

### 5.3 Security Improvements

1. **Eliminates Single Point of Failure**: No central authentication server to compromise
2. **Reduces Attack Surface**: Removes OAuth/DPoP/JWT validation complexity
3. **Simplifies Trust Model**: No dependency on external identity providers
4. **Maintains Privacy**: Servers still never see user pins or identities

### 5.4 Threat Analysis

| Threat | Current System | Authentication Code System | Mitigation |
|--------|----------------|----------------------------|------------|
| **Fake Authentication Codes** | OAuth token validation | Format + entropy validation | Proof-of-work, rate limiting |
| **Pin Brute Force** | Blinding + guess limits | Blinding + guess limits (unchanged) | 10 attempts max per backup |
| **Server Compromise** | T-of-N Shamir security | T-of-N Shamir security (unchanged) | Distributed trust model |
| **DDoS Amplification** | Rate limiting | Adaptive proof-of-work | Multi-layer defense |
| **Replay Attacks** | Session binding | Server-specific codes | Unique codes per server |

**Key Security Insight**: Authentication codes only replace the OAuth authentication layer. The core cryptographic security still comes from:
- **Pin protection**: Ed25519 discrete log hardness via blinding protocol
- **Distributed trust**: T-of-N Shamir secret sharing across independent servers  
- **Guess limiting**: Maximum 10 attempts per backup across all servers
- **Key derivation**: `enc_key = HKDF(S.x || S.y)` where `S = s * U`

---

## 6. Authentication Code Security Model & Use Cases

### 6.1 Security Model Clarification

**Primary Security**: The user's pin/password in their head (low-entropy knowledge factor)
**Secondary Security**: Authentication code (prevents DoS attacks on guess limits)

The authentication code is **not** a secret that provides cryptographic security. It serves solely to authenticate the user to prevent unauthorized parties from exhausting the 10-guess limit. The real security comes from the user proving they know their pin/password within the limited guess attempts.

**Critical Security Detail**: Clients never send the raw authentication code to servers. Instead, they send `SHA256(auth_code || server_url)`. This prevents a compromised server from using the authentication code to attack the user on other servers. Each server only sees its own derived code and cannot compute codes for other servers.

### 6.2 Use Case Examples

#### Disk Encryption (BitLocker, FileVault)
```
Storage: Authentication code stored in clear text on encrypted disk
Security: Attacker with disk access can make 10 guesses at user's pin
Comparison: Current OAuth approach would store 90-day valid token on disk anyway
Benefit: Eliminates dependency on external auth servers
```

#### Password Manager (1Password, Bitwarden)  
```
Storage: Authentication code stored with encrypted vault
Security: Attacker with vault file can make 10 guesses at master password
Comparison: Current systems rely on PBKDF2/Argon2 iteration counts for security
Benefit: Provides hardware-backed security via distributed servers
```

#### Phone Backup (iPhone, Android)
```
Storage: Authentication code synced with encrypted backup to cloud
Security: Attacker with backup can make 10 guesses at device unlock pin
Comparison: Apple's ADP gives Apple 10 guesses anyway, but with no transparency
Benefit: Distributed trust across multiple jurisdictions, full transparency
```

#### Secure File Storage
```
Storage: Authentication code provided by user during recovery
Security: Only user knows the authentication code, must remember it
Comparison: Similar to current password-based encryption
Benefit: Stronger security through distributed threshold cryptography
```

### 6.3 Key Insight: DoS Equivalence

In all use cases, an attacker who can access the authentication code could already DoS the user by:
- **Current OAuth system**: Using cached tokens to exhaust guess limits
- **Authentication code system**: Using the code to exhaust guess limits

The authentication code doesn't make the system less secure - it **eliminates the central auth server dependency** while maintaining the same security properties.

### 6.4 When Authentication Codes Are Appropriate

**Good Use Cases**:
- Disk encryption (code stored on encrypted disk)
- Application data protection (code stored with encrypted data)
- Backup systems (code travels with backup)
- Any scenario where OAuth tokens would be cached locally anyway

---

## 7. DDoS Defense Strategy

### 7.1 Adaptive Proof-of-Work

When server load increases, the system can require clients to solve computational puzzles before processing requests. The difficulty automatically adjusts based on current server load:

- **Normal load**: No proof-of-work required
- **High load**: Require hash puzzles with increasing difficulty
- **Attack conditions**: Maximum difficulty to slow down attackers

### 7.2 Time-Lock Puzzles

For sustained attacks, servers can require clients to solve time-lock puzzles that force a minimum delay before requests are processed. This prevents rapid-fire authentication attempts.

### 7.3 Multi-Layer Defense

1. **Pre-Authentication Rate Limiting**: IP-based, geographic filtering
2. **Authentication Code Validation**: Format, entropy, blacklists
3. **Proof-of-Work**: Adaptive difficulty based on server load
4. **Time-Lock Puzzles**: Force minimum time delays during attacks
5. **Behavioral Analysis**: Detect and block automated attack patterns

---

## 8. Implementation Architecture

### 8.1 Server-Side Changes

**New Authentication Middleware**:
- Replace OAuth/DPoP validation with authentication code validation
- Implement format validation for 64-character SHA256 hashes
- Add entropy checking and blacklist management
- Integrate with existing DDoS defense mechanisms

**Updated RPC Handlers**:
- Modify `RegisterSecret` to accept server authentication codes
- Update `RecoverSecret` to authenticate via auth codes
- Add `ListBackups` method for backup selection
- Maintain all existing OpenADP cryptographic protocols
- Preserve guess limiting and rate limiting functionality

### 8.2 Client-Side Changes

**Authentication Code Management**:
- Generate secure 128-bit random authentication codes
- Derive server-specific codes using SHA256(auth_code || server_url)
- Manage authentication codes for multiple servers
- Provide secure storage recommendations

**Updated Client Tools**:
- Integrate authentication code generation into backup creation
- Implement backup selection workflow for recovery
- Maintain all existing OpenADP cryptographic protocols
- Support multi-device backup scenarios
- Provide clear user guidance for authentication code storage

---

## 9. Performance Analysis

### 9.1 Authentication Latency Comparison

| Operation | Current System | Authentication Code System | Improvement |
|-----------|----------------|----------------------------|-------------|
| **First Auth** | ~5-10 seconds | ~100ms | 50-100x faster |
| **Subsequent Auth** | ~500ms | ~10ms | 50x faster |
| **Network Calls** | 5+ round trips | 1 round trip | 5x fewer |
| **Browser Dependency** | Required | None | Eliminated |

### 9.2 Server Resource Usage

| Resource | Current System | Authentication Code System | Improvement |
|----------|----------------|----------------------------|-------------|
| **Memory** | JWT cache + JWKS cache | Auth code validation | 80% reduction |
| **CPU** | JWT validation + DPoP | SHA256 + entropy check | 90% reduction |
| **Network** | JWKS fetching | None | 100% reduction |
| **Dependencies** | PyJWT, cryptography | hashlib (built-in) | Simplified |

---

## 10. Operational Benefits

### 10.1 Deployment Simplification

**Removed Components:**
- Keycloak server infrastructure
- OAuth endpoint configuration
- JWKS caching and refresh logic
- DPoP key management
- JWT validation libraries

**Simplified Configuration:**
```yaml
# Old configuration (50+ lines)
auth:
  enabled: true
  issuer: https://auth.openadp.org/realms/openadp
  jwks_url: https://auth.openadp.org/realms/openadp/protocol/openid-connect/certs
  cache_ttl: 3600
  dpop_validation: true
  # ... many more options

# New configuration (5 lines)
auth:
  enabled: true
  min_entropy_bits: 128
  max_attempts_per_code: 10
  ddos_defense: adaptive
```

### 10.2 Monitoring and Alerting

**Simplified Metrics:**
- Recovery code validation rate
- DDoS defense activation frequency
- Server load and response times
- Code usage patterns

**Removed Complexity:**
- OAuth flow monitoring
- JWT validation failures
- JWKS fetch failures
- Token refresh cycles

---

## 11. Implementation Approach

Since OpenADP has no existing users, the implementation can be straightforward without migration complexity:

### Core Implementation Tasks

**Server-Side Changes**:
- Replace OAuth/DPoP middleware with authentication code validation
- Update RPC handlers to accept server authentication codes
- Implement DDoS defense mechanisms
- Add backup listing functionality for multi-device scenarios

**Client-Side Changes**:
- Add authentication code generation and management
- Integrate server-specific code derivation
- Implement backup selection workflow
- Update all client tools to use authentication codes

**Database Updates**:
- Add `auth_code` field to backup records
- Maintain existing Shamir share storage structure
- Preserve all existing security mechanisms (guess limits, expiration)

**Testing and Validation**:
- Comprehensive end-to-end testing
- Performance benchmarking against current system
- Security audit of authentication code implementation
- Load testing with DDoS defense mechanisms

### Implementation Benefits

**Simplified Deployment**:
- No migration phase required (no existing users)
- Remove Keycloak server infrastructure immediately
- Eliminate OAuth/DPoP/JWT complexity from day one
- Single authentication system from launch

**Reduced Risk**:
- No backward compatibility requirements
- No user migration concerns
- Simpler testing scenarios
- Cleaner codebase without legacy support

---

## 12. Risk Assessment and Mitigation

### High-Risk Items

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **DDoS attacks overwhelm system** | Medium | High | Comprehensive defense layers, monitoring |
| **Users lose recovery codes** | Medium | Medium | Clear storage guidance, multiple backup options |
| **User adoption resistance** | Low | Medium | Clear migration path, user education |
| **Security vulnerabilities** | Low | High | External security audit, penetration testing |

### Medium-Risk Items

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Performance degradation** | Low | Medium | Extensive load testing, optimization |
| **Migration complexity** | Medium | Low | Phased rollout, comprehensive testing |
| **Documentation gaps** | Medium | Low | User testing, feedback incorporation |

---

## 13. Success Metrics

### Technical Metrics
- **Authentication Latency**: <100ms (vs 5-10s current)
- **System Availability**: >99.9% (vs current Keycloak dependency)
- **Resource Usage**: <20% of current server resources
- **Code Complexity**: <10% of current authentication code

### User Experience Metrics
- **Setup Time**: <5 minutes for new users
- **Authentication Success Rate**: >99.5%
- **User Satisfaction**: >90% positive feedback
- **Support Tickets**: <50% of current auth-related tickets

### Security Metrics
- **Zero Critical Vulnerabilities**: External security audit
- **DDoS Resistance**: Survive 10x normal load
- **Privacy Enhancement**: No user identity leakage to servers
- **Attack Surface Reduction**: 90% fewer external dependencies

---

## 14. Conclusion

The authentication code system represents a fundamental architectural improvement for OpenADP. By eliminating the single point of failure inherent in centralized authentication and dramatically simplifying the system, we achieve:

1. **Better Reliability**: No central auth server dependency
2. **Maintained Security**: All cryptographic properties preserved
3. **Superior User Experience**: Faster, simpler authentication
4. **Operational Excellence**: Easier deployment and maintenance
5. **Architectural Alignment**: Distributed trust model matches OpenADP philosophy

**Key Insight**: Authentication codes only replace the OAuth authentication layer - they do not change OpenADP's core cryptographic security model. The real security still comes from:
- User's pin/password (protected by blinding)
- Distributed Shamir secret sharing (T-of-N threshold)
- Limited guess attempts (10 max per backup)
- Strong key derivation (`enc_key = HKDF(S.x || S.y)`)

The proposed implementation phases provide a clear path forward with manageable risk and measurable progress. The system can be deployed incrementally while maintaining backward compatibility, ensuring a smooth transition for existing users.

This redesign positions OpenADP as a truly distributed, resilient system that can scale globally without central dependencies—fulfilling the original vision of nation-state-resistant data protection while maintaining complete transparency and cryptographic security.
